{"meta":{"title":"My Blog","subtitle":"博客","description":"","author":"李烨","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"线性表1(Linear List)","slug":"线性表1(Linear List)","date":"2020-04-03T03:49:02.308Z","updated":"2020-04-03T04:01:45.711Z","comments":true,"path":"2020/04/03/线性表1(Linear List)/","link":"","permalink":"http://yoursite.com/2020/04/03/%E7%BA%BF%E6%80%A7%E8%A1%A81(Linear%20List)/","excerpt":"","text":"线性表(Linear List)由同类型数据元素构成有序序列的线性结构. 特征 表中元素个数为线性表长度. 线性表没有元素时称空表. 表起始位置为表头, 结束位置为表尾. 顺序结构线性表通过数组形式储存数据. 查找方便, 修改困难. 1234567typedef struct LNode *List; struct LNode&#123; ElementType Data[MAXSIZE]; int last; //指向表尾 &#125;;struct LNode L;List PtrL; 访问下标i的元素时: 1L.Data[i];/*或者*/PtrL-&gt;Data[i]; 主要操作 List MakeEmpty(): 初始化空表. 123456List MakeEmpty(void)&#123; List PtrL; PtrL = (List)malloc(sizeof(struct LNode)); PtrL-&gt; Last = -1; return PtrL;&#125; int Find(ElementType X, Lits L): 查找X第一次出现的位置. 12345678int Find(ElementType X, List PtrL)&#123; int i=0; while (i &lt;= PtrL -&gt; Last &amp;&amp; PtrL -&gt; Data[i] != X)&#123; i++; &#125;if (i &gt; PtrL -&gt; Last) return -1; //没找到返回-1. else return i;&#125; void Insert(ElementType X, int i, List L): 在i位数据前插入X元素. 1234567891011121314void Insert(ElementType X, int i , List PtrL)&#123; int j; if (PtrL -&gt; Last == MAXSIZE - 1)&#123; printf(\"表满\"); return ; &#125;if (i &lt; 1 || i &gt; PtrL -&gt; Last + 2)&#123; printf(\"位置不合法\"); return ; &#125;for (j = PtrL -&gt; Last; j &gt;= i - 1; j--)&#123; PrtL -&gt; Data[j+1] = PtrL -&gt; Data[j]; //把i位之前的数字都向后移动一位 &#125;PtrL -&gt; Data[i-1] = X; //新元素插入 PtrL -&gt; Last++; //Last还是指向最后一位元素 return ;&#125; void Delete (int i, List L): 删除第i个元素. 12345678910void Delete(int i, List PtrL)&#123; int j; if (i &lt; 1 || i &gt; PtrL -&gt; Last + 1)&#123; printf(\"不存在第%d个元素\"); return ; &#125;for (j = i; j &lt;= PtrL -&gt; Last; j++)&#123; PtrL -&gt; Data[j-1] = PtrL -&gt; Data[j]; //将i位之前的数字都向前移动一位 &#125;PtrL -&gt; Last --; //Last还是指向最后一位 return ;&#125; 链式结构线性表通过链表形式储存数据. 修改方便, 查找困难. 1234567typedef struct LNode *List;struct LNode&#123; ElementType Data; List Next;&#125;;struct LNode L;List PtrL; 主要操作 int Length(List PtrL): 返回线性表长度. 12345678int Length(List PtrL)&#123; int j = 0; while (p)&#123; p = p -&gt; Next; j++; &#125; return j;&#125; List FindIth(int i, List PtrL): 寻找第i个数据的节点地址. 123456789List FindIth(int i, List PtrL)&#123; List p= PtrL; int j = 1; while (p != NULL &amp;&amp; j &lt; i)&#123; p = p -&gt; Next; j++; &#125;if (j == i) return p; //返回第i位的数据地址 else return NULL; //否则返回空&#125; List Find(ElementType X, List PtrL): 返回X元素所在的地址. 123456List Find(ElementType X, List PtrL)&#123; List p = PtrL; while (p != NULL &amp;&amp; p -&gt; Data != X)&#123; p = p -&gt; Next; &#125;return p;&#125; List Insert(ElementType X, List PtrL): 在第i位插入一个新元素. 12345678910111213141516171819List Insert(ElementType X,int i, List PtrL)&#123; List P, s; if (i == 1)&#123; s = (List)malloc(sizeof(struct LNode)); s -&gt; Data = x; s -&gt; Next = PtrL; return s; &#125;p = FindIth(i-1, PtrL); //寻找i-1的点是否存在 if (p == NULL)&#123; printf(\"参数不合法\"); return NULL &#125;else&#123; s = (List)malloc(sizeof(struct LNode)); s -&gt; Data = x; s -&gt; Next = p -&gt; Next; p -&gt; Next = s; return PtrL; //返回新链表的指针 &#125;&#125; List Delete(int i, List L): 删除第i位的元素. 12345678910111213141516171819202122List Delete(int i, List L)&#123; List p, s; if (i == 1)&#123; //如果要删除的是头节点 s = PtrL; if (PtrL != NULL) PtrL = PtrL -&gt; Next; else return NULL; free(s); return PtrL; &#125;p = FindIth(i-1,PtrL); //查找第i-1个节点 if (p == NULL)&#123; printf(\"第%d个节点不存在\",i - 1); return NULL; &#125;else if (p -&gt; Next == NULL)&#123; printf(\"第%d个节点不存在\",i); return NULL; &#125;else&#123; s = p -&gt; Next; p -&gt; Next = s -&gt; Next; free(s); return PtrL; &#125;&#125; 广义表 广义表是线性表的推广 对普通线性表, 元素基本都似乎单元素, 在广义表中, 元素可以是另一个广义表 123456789typedef struct GNode *Glist;struct GNode&#123; int Tag; //union的标记位, 0表示元素, 1表示广义表 union&#123; ElementType Data; Glist SubList; &#125;URegion; GList Next;&#125;; 多重链表 多重链表节点可能同时隶属多个链. 多重链表中节点的指针域会有多个, 但是有多个指针域的链表不一定是多重链表(比如双向链表) 1234567891011121314typedef struct GNode *Glist;strcut DataType&#123; ElementType Data; int y; int x;&#125;;struct GNode&#123; union&#123; strcut DataType Data; Glist head; &#125;URegion; Glist Left; GList Right;&#125;;","categories":[],"tags":[]},{"title":"线性表2(Linear List)","slug":"线性表2(Linear List)","date":"2020-04-03T03:43:56.910Z","updated":"2020-04-03T03:43:56.910Z","comments":true,"path":"2020/04/03/线性表2(Linear List)/","link":"","permalink":"http://yoursite.com/2020/04/03/%E7%BA%BF%E6%80%A7%E8%A1%A82(Linear%20List)/","excerpt":"","text":"堆栈(stack)具有一定操作约束的线性表, 只在一端做插入/删除操作. 数据先进后出. 顺序结构堆栈通过数组结构实现. 123456#define MaxSize Number//储存数据元素的最大个数typedef struct SNode *Stack;struct SNode&#123; ElementType Data[MaxSize]; int Top;&#125;; 主要操作 void Push(Stack PtrS, ElementType item): 往栈放入元素item. 12345678910void Push(Stack PtrS, ElementType item)&#123; if (PtrS -&gt; Top == MaxSize - 1)&#123; //当Top为MaxSize-1表示放满栈 printf(\"栈已满\"); return ; &#125;else&#123; PtrS -&gt; Top++; //先移位, 再放入数据 PtrS -&gt; Data[PtrS -&gt; Top] = item; return ; &#125;&#125; ElementType Pop(Stack PtrS): 释放栈最上面的数据. 12345678ElementType Pop(Stack PtrS)&#123; if (PtrS -&gt; Top == -1)&#123; printf(\"栈空\"); // 当Top为-1的时候表示栈空 return ERROR; //ERROR是ElementType的特殊值, 标记错误 &#125;else&#123; return (PtrS -&gt; Data[(PtrS -&gt; Top)--]); //先取出数据, 再移位 &#125;&#125; 链式结构堆栈通过链表结构实现. 12345typedef struct SNode *Stack; //栈头必须在头节点struct SNode&#123; ElementType Data; struct SNode *Next;&#125;; 主要操作 void Push(ElementType item, Stack S): 往堆栈放入item. 12345678void Push(ElementType item, Stack S)&#123; Stack Tmp; Tmp = (Stack)malloc(sizeof(struct SNode)); Tmp -&gt; Data = item; Tmp -&gt; Next = S -&gt; Next; S -&gt; Next = Tmp; return ;&#125; ElementType Pop(Stack S): 释放堆栈最上面的数据. 12345678910111213ElementType Pop(Stack S)&#123; Stack Tmp; ElementType TopElem; if (IsEmpty(s))&#123; //判断此时堆栈是否空栈 printf(\"栈空\"); return ERROR; &#125;else&#123; Tmp = S -&gt; Next; S -&gt; Next = Tmp -&gt; Next; TopElem = Tmp -&gt; Data; free(Tmp); &#125;return TopElem;&#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}