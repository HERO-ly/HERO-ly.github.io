{"meta":{"title":"My Blog","subtitle":"博客","description":"","author":"李烨","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"线性表","slug":"线性表","date":"2020-04-04T09:50:01.000Z","updated":"2020-04-04T10:39:26.530Z","comments":true,"path":"2020/04/04/线性表/","link":"","permalink":"http://yoursite.com/2020/04/04/%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"线性表(Linear List)由同类型数据元素构成有序序列的线性结构. 特征1) 表中元素个数为线性表长度. 2) 线性表没有元素时称空表. 3) 表起始位置为表头, 结束位置为表尾.","text":"线性表(Linear List)由同类型数据元素构成有序序列的线性结构. 特征1) 表中元素个数为线性表长度. 2) 线性表没有元素时称空表. 3) 表起始位置为表头, 结束位置为表尾. 顺序结构线性表通过数组形式储存数据. 查找方便, 修改困难. 1234567typedef struct LNode *List; struct LNode&#123; ElementType Data[MAXSIZE]; int last; //指向表尾 &#125;;struct LNode L;List PtrL; 访问下标i的元素时: 1L.Data[i];/*或者*/PtrL-&gt;Data[i]; 主要操作 List MakeEmpty(): 初始化空表. 123456List MakeEmpty(void)&#123; List PtrL; PtrL = (List)malloc(sizeof(struct LNode)); PtrL-&gt; Last = -1; return PtrL;&#125; int Find(ElementType X, Lits L): 查找X第一次出现的位置. 12345678int Find(ElementType X, List PtrL)&#123; int i=0; while (i &lt;= PtrL -&gt; Last &amp;&amp; PtrL -&gt; Data[i] != X)&#123; i++; &#125;if (i &gt; PtrL -&gt; Last) return -1; //没找到返回-1. else return i;&#125; void Insert(ElementType X, int i, List L): 在i位数据前插入X元素. 1234567891011121314void Insert(ElementType X, int i , List PtrL)&#123; int j; if (PtrL -&gt; Last == MAXSIZE - 1)&#123; printf(\"表满\"); return ; &#125;if (i &lt; 1 || i &gt; PtrL -&gt; Last + 2)&#123; printf(\"位置不合法\"); return ; &#125;for (j = PtrL -&gt; Last; j &gt;= i - 1; j--)&#123; PrtL -&gt; Data[j+1] = PtrL -&gt; Data[j]; //把i位之前的数字都向后移动一位 &#125;PtrL -&gt; Data[i-1] = X; //新元素插入 PtrL -&gt; Last++; //Last还是指向最后一位元素 return ;&#125; void Delete (int i, List L): 删除第i个元素. 12345678910void Delete(int i, List PtrL)&#123; int j; if (i &lt; 1 || i &gt; PtrL -&gt; Last + 1)&#123; printf(\"不存在第%d个元素\"); return ; &#125;for (j = i; j &lt;= PtrL -&gt; Last; j++)&#123; PtrL -&gt; Data[j-1] = PtrL -&gt; Data[j]; //将i位之前的数字都向前移动一位 &#125;PtrL -&gt; Last --; //Last还是指向最后一位 return ;&#125; 链式结构线性表通过链表形式储存数据. 修改方便, 查找困难. 1234567typedef struct LNode *List;struct LNode&#123; ElementType Data; List Next;&#125;;struct LNode L;List PtrL; 主要操作 int Length(List PtrL): 返回线性表长度. 12345678int Length(List PtrL)&#123; int j = 0; while (p)&#123; p = p -&gt; Next; j++; &#125; return j;&#125; List FindIth(int i, List PtrL): 寻找第i个数据的节点地址. 123456789List FindIth(int i, List PtrL)&#123; List p= PtrL; int j = 1; while (p != NULL &amp;&amp; j &lt; i)&#123; p = p -&gt; Next; j++; &#125;if (j == i) return p; //返回第i位的数据地址 else return NULL; //否则返回空&#125; List Find(ElementType X, List PtrL): 返回X元素所在的地址. 123456List Find(ElementType X, List PtrL)&#123; List p = PtrL; while (p != NULL &amp;&amp; p -&gt; Data != X)&#123; p = p -&gt; Next; &#125;return p;&#125; List Insert(ElementType X, List PtrL): 在第i位插入一个新元素. 12345678910111213141516171819List Insert(ElementType X,int i, List PtrL)&#123; List P, s; if (i == 1)&#123; s = (List)malloc(sizeof(struct LNode)); s -&gt; Data = x; s -&gt; Next = PtrL; return s; &#125;p = FindIth(i-1, PtrL); //寻找i-1的点是否存在 if (p == NULL)&#123; printf(\"参数不合法\"); return NULL &#125;else&#123; s = (List)malloc(sizeof(struct LNode)); s -&gt; Data = x; s -&gt; Next = p -&gt; Next; p -&gt; Next = s; return PtrL; //返回新链表的指针 &#125;&#125; List Delete(int i, List L): 删除第i位的元素. 12345678910111213141516171819202122List Delete(int i, List L)&#123; List p, s; if (i == 1)&#123; //如果要删除的是头节点 s = PtrL; if (PtrL != NULL) PtrL = PtrL -&gt; Next; else return NULL; free(s); return PtrL; &#125;p = FindIth(i-1,PtrL); //查找第i-1个节点 if (p == NULL)&#123; printf(\"第%d个节点不存在\",i - 1); return NULL; &#125;else if (p -&gt; Next == NULL)&#123; printf(\"第%d个节点不存在\",i); return NULL; &#125;else&#123; s = p -&gt; Next; p -&gt; Next = s -&gt; Next; free(s); return PtrL; &#125;&#125; 广义表 广义表是线性表的推广 对普通线性表, 元素基本都似乎单元素, 在广义表中, 元素可以是另一个广义表 123456789typedef struct GNode *Glist;struct GNode&#123; int Tag; //union的标记位, 0表示元素, 1表示广义表 union&#123; ElementType Data; Glist SubList; &#125;URegion; GList Next;&#125;; 多重链表 多重链表节点可能同时隶属多个链. 多重链表中节点的指针域会有多个, 但是有多个指针域的链表不一定是多重链表(比如双向链表) 1234567891011121314typedef struct GNode *Glist;strcut DataType&#123; ElementType Data; int y; int x;&#125;;struct GNode&#123; union&#123; strcut DataType Data; Glist head; &#125;URegion; Glist Left; GList Right;&#125;;","categories":[],"tags":[]},{"title":"post","slug":"post","date":"2020-04-04T09:49:25.000Z","updated":"2020-04-04T09:49:25.456Z","comments":true,"path":"2020/04/04/post/","link":"","permalink":"http://yoursite.com/2020/04/04/post/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"线性表3(Linear List)","slug":"线性表3(Linear List)","date":"2020-04-03T07:21:02.736Z","updated":"2020-04-03T08:51:08.982Z","comments":true,"path":"2020/04/03/线性表3(Linear List)/","link":"","permalink":"http://yoursite.com/2020/04/03/%E7%BA%BF%E6%80%A7%E8%A1%A83(Linear%20List)/","excerpt":"队列(Queue)具有一定操作约束的线性表, 只能在一段插入, 另一端删除. 数据先进先出.","text":"队列(Queue)具有一定操作约束的线性表, 只能在一段插入, 另一端删除. 数据先进先出. 顺序结构队列通过数组结构实现. 1234567#define MaxSize Number//储存数组的最大个数struct QNode&#123; ElementType Data[MaxSize]; int rear; //指向尾元素 int front; //指向头元素&#125;;typedef struct QNode *Queue; 主要操作 void AddQ(Queue PtrQ, ElementType item): 往队列中放入元素item. 123456789/*在循坏队列中, 无法判断队列是否空或者满, 所以通过少放一位数据, 来判断队列状态*//*也可以用tag等标识符来判断队列状态*/void AddQ(Queue PtrQ, ElementType item)&#123; if ((PtrQ -&gt; rear + 1) % MaxSize == PtrQ -&gt; front)&#123; printf(\"队列已满\"); return ; &#125;PtrQ -&gt; rear = (PtrQ -&gt; rear + 1)% MaxSize; //求余实现循环储存 PtrQ -&gt; Data[PtrQ -&gt; rear] = item;&#125; ElementType DeleteQ(Queue PtrQ): 释放队列头元素. 123456789ElementType DeleteQ(Queue PtrQ)&#123; if (PtrQ -&gt; front == PtrQ -&gt; rear)&#123; printf(\"队列空\"); return ERROR; &#125;else&#123; PtrQ -&gt; front = (PtrQ -&gt; front + 1) % MaxSize; return PtrQ -&gt; Data[PtrQ -&gt; front]; &#125;&#125; 链式结构队列通过链表结构实现. 1234567891011//规定front指向头结点, rear指向尾结点struct Node&#123; ElementType Data; struct Node *Next;&#125;;struct QNode&#123; //指向一个链表的头和尾 struct Node *rear; //指向尾结点 struct Node *front; //指向头结点&#125;;typedef struct QNode *Queue;Queue PtrQ; 主要操作 void AddQ(Queue PtrQ, ElementType item): 往队列中放入元素item. 1234567891011void AddQ(Queue PtrQ, ElementType item)&#123; struct Node *Tmp; Tmp = (struct Node *)malloc(sizeof(struct Node)); if (PtrQ -&gt; front == NULL)&#123; PtrQ -&gt; front = PtrQ -&gt; rear = Tmp; &#125;else&#123; PtrQ -&gt; rear = PtrQ -&gt; rear -&gt; Next; &#125;Tmp -&gt; Next = NULL; Tmp -&gt; Data = item;&#125; ElementType DeleteQ(Queue PtrQ): 释放队列头元素. 12345678910111213141516ElementType DeleteQ(Queue PtrQ)&#123; struct Node *Tmp; ElementType Tmp_itme; if (PtrQ -&gt; front == NULL)&#123; prntf(\"队列空\"); return ERROR; &#125;Tmp = PtrQ -&gt; front; if (PtrQ -&gt; front == PtrQ -&gt; rear)&#123; PtrQ -&gt; front = PtrQ -&gt; rear =NULL; &#125;else&#123; PtrQ -&gt; front = PtrQ -&gt; front -&gt; Next; &#125;Tmp_itme = Tmp -&gt; Data; free(Tmp); return Tmp_itme;&#125;","categories":[],"tags":[]},{"title":"线性表1(Linear List)","slug":"线性表1(Linear List)","date":"2020-04-03T05:31:49.035Z","updated":"2020-04-03T08:58:18.694Z","comments":true,"path":"2020/04/03/线性表1(Linear List)/","link":"","permalink":"http://yoursite.com/2020/04/03/%E7%BA%BF%E6%80%A7%E8%A1%A81(Linear%20List)/","excerpt":"线性表(Linear List)由同类型数据元素构成有序序列的线性结构. 特征1) 表中元素个数为线性表长度. 2) 线性表没有元素时称空表. 3) 表起始位置为表头, 结束位置为表尾.","text":"线性表(Linear List)由同类型数据元素构成有序序列的线性结构. 特征1) 表中元素个数为线性表长度. 2) 线性表没有元素时称空表. 3) 表起始位置为表头, 结束位置为表尾. 顺序结构线性表通过数组形式储存数据. 查找方便, 修改困难. 1234567typedef struct LNode *List; struct LNode&#123; ElementType Data[MAXSIZE]; int last; //指向表尾 &#125;;struct LNode L;List PtrL; 访问下标i的元素时: 1L.Data[i];/*或者*/PtrL-&gt;Data[i]; 主要操作 List MakeEmpty(): 初始化空表. 123456List MakeEmpty(void)&#123; List PtrL; PtrL = (List)malloc(sizeof(struct LNode)); PtrL-&gt; Last = -1; return PtrL;&#125; int Find(ElementType X, Lits L): 查找X第一次出现的位置. 12345678int Find(ElementType X, List PtrL)&#123; int i=0; while (i &lt;= PtrL -&gt; Last &amp;&amp; PtrL -&gt; Data[i] != X)&#123; i++; &#125;if (i &gt; PtrL -&gt; Last) return -1; //没找到返回-1. else return i;&#125; void Insert(ElementType X, int i, List L): 在i位数据前插入X元素. 1234567891011121314void Insert(ElementType X, int i , List PtrL)&#123; int j; if (PtrL -&gt; Last == MAXSIZE - 1)&#123; printf(\"表满\"); return ; &#125;if (i &lt; 1 || i &gt; PtrL -&gt; Last + 2)&#123; printf(\"位置不合法\"); return ; &#125;for (j = PtrL -&gt; Last; j &gt;= i - 1; j--)&#123; PrtL -&gt; Data[j+1] = PtrL -&gt; Data[j]; //把i位之前的数字都向后移动一位 &#125;PtrL -&gt; Data[i-1] = X; //新元素插入 PtrL -&gt; Last++; //Last还是指向最后一位元素 return ;&#125; void Delete (int i, List L): 删除第i个元素. 12345678910void Delete(int i, List PtrL)&#123; int j; if (i &lt; 1 || i &gt; PtrL -&gt; Last + 1)&#123; printf(\"不存在第%d个元素\"); return ; &#125;for (j = i; j &lt;= PtrL -&gt; Last; j++)&#123; PtrL -&gt; Data[j-1] = PtrL -&gt; Data[j]; //将i位之前的数字都向前移动一位 &#125;PtrL -&gt; Last --; //Last还是指向最后一位 return ;&#125; 链式结构线性表通过链表形式储存数据. 修改方便, 查找困难. 1234567typedef struct LNode *List;struct LNode&#123; ElementType Data; List Next;&#125;;struct LNode L;List PtrL; 主要操作 int Length(List PtrL): 返回线性表长度. 12345678int Length(List PtrL)&#123; int j = 0; while (p)&#123; p = p -&gt; Next; j++; &#125; return j;&#125; List FindIth(int i, List PtrL): 寻找第i个数据的节点地址. 123456789List FindIth(int i, List PtrL)&#123; List p= PtrL; int j = 1; while (p != NULL &amp;&amp; j &lt; i)&#123; p = p -&gt; Next; j++; &#125;if (j == i) return p; //返回第i位的数据地址 else return NULL; //否则返回空&#125; List Find(ElementType X, List PtrL): 返回X元素所在的地址. 123456List Find(ElementType X, List PtrL)&#123; List p = PtrL; while (p != NULL &amp;&amp; p -&gt; Data != X)&#123; p = p -&gt; Next; &#125;return p;&#125; List Insert(ElementType X, List PtrL): 在第i位插入一个新元素. 12345678910111213141516171819List Insert(ElementType X,int i, List PtrL)&#123; List P, s; if (i == 1)&#123; s = (List)malloc(sizeof(struct LNode)); s -&gt; Data = x; s -&gt; Next = PtrL; return s; &#125;p = FindIth(i-1, PtrL); //寻找i-1的点是否存在 if (p == NULL)&#123; printf(\"参数不合法\"); return NULL &#125;else&#123; s = (List)malloc(sizeof(struct LNode)); s -&gt; Data = x; s -&gt; Next = p -&gt; Next; p -&gt; Next = s; return PtrL; //返回新链表的指针 &#125;&#125; List Delete(int i, List L): 删除第i位的元素. 12345678910111213141516171819202122List Delete(int i, List L)&#123; List p, s; if (i == 1)&#123; //如果要删除的是头节点 s = PtrL; if (PtrL != NULL) PtrL = PtrL -&gt; Next; else return NULL; free(s); return PtrL; &#125;p = FindIth(i-1,PtrL); //查找第i-1个节点 if (p == NULL)&#123; printf(\"第%d个节点不存在\",i - 1); return NULL; &#125;else if (p -&gt; Next == NULL)&#123; printf(\"第%d个节点不存在\",i); return NULL; &#125;else&#123; s = p -&gt; Next; p -&gt; Next = s -&gt; Next; free(s); return PtrL; &#125;&#125; 广义表 广义表是线性表的推广 对普通线性表, 元素基本都似乎单元素, 在广义表中, 元素可以是另一个广义表 123456789typedef struct GNode *Glist;struct GNode&#123; int Tag; //union的标记位, 0表示元素, 1表示广义表 union&#123; ElementType Data; Glist SubList; &#125;URegion; GList Next;&#125;; 多重链表![多重链表样例](.\\线性表1(Linear List)\\muti.png) 多重链表节点可能同时隶属多个链. 多重链表中节点的指针域会有多个, 但是有多个指针域的链表不一定是多重链表(比如双向链表) 1234567891011121314typedef struct GNode *Glist;strcut DataType&#123; ElementType Data; int y; int x;&#125;;struct GNode&#123; union&#123; strcut DataType Data; Glist head; &#125;URegion; Glist Left; GList Right;&#125;; ![test](C:线性表1(Linear List)\\test.jpg)","categories":[],"tags":[]},{"title":"线性表2(Linear List)","slug":"线性表2(Linear List)","date":"2020-04-03T03:43:56.910Z","updated":"2020-04-03T08:50:50.558Z","comments":true,"path":"2020/04/03/线性表2(Linear List)/","link":"","permalink":"http://yoursite.com/2020/04/03/%E7%BA%BF%E6%80%A7%E8%A1%A82(Linear%20List)/","excerpt":"堆栈(stack)具有一定操作约束的线性表, 只在一端做插入/删除操作. 数据先进后出.","text":"堆栈(stack)具有一定操作约束的线性表, 只在一端做插入/删除操作. 数据先进后出. 顺序结构堆栈通过数组结构实现. 123456#define MaxSize Number//储存数据元素的最大个数typedef struct SNode *Stack;struct SNode&#123; ElementType Data[MaxSize]; int Top;&#125;; 主要操作 void Push(Stack PtrS, ElementType item): 往栈放入元素item. 12345678910void Push(Stack PtrS, ElementType item)&#123; if (PtrS -&gt; Top == MaxSize - 1)&#123; //当Top为MaxSize-1表示放满栈 printf(\"栈已满\"); return ; &#125;else&#123; PtrS -&gt; Top++; //先移位, 再放入数据 PtrS -&gt; Data[PtrS -&gt; Top] = item; return ; &#125;&#125; ElementType Pop(Stack PtrS): 释放栈最上面的数据. 12345678ElementType Pop(Stack PtrS)&#123; if (PtrS -&gt; Top == -1)&#123; printf(\"栈空\"); // 当Top为-1的时候表示栈空 return ERROR; //ERROR是ElementType的特殊值, 标记错误 &#125;else&#123; return (PtrS -&gt; Data[(PtrS -&gt; Top)--]); //先取出数据, 再移位 &#125;&#125; 链式结构堆栈通过链表结构实现. 12345typedef struct SNode *Stack; //栈头必须在头节点struct SNode&#123; ElementType Data; struct SNode *Next;&#125;; 主要操作 void Push(ElementType item, Stack S): 往堆栈放入item. 12345678void Push(ElementType item, Stack S)&#123; Stack Tmp; Tmp = (Stack)malloc(sizeof(struct SNode)); Tmp -&gt; Data = item; Tmp -&gt; Next = S -&gt; Next; S -&gt; Next = Tmp; return ;&#125; ElementType Pop(Stack S): 释放堆栈最上面的数据. 12345678910111213ElementType Pop(Stack S)&#123; Stack Tmp; ElementType TopElem; if (IsEmpty(s))&#123; //判断此时堆栈是否空栈 printf(\"栈空\"); return ERROR; &#125;else&#123; Tmp = S -&gt; Next; S -&gt; Next = Tmp -&gt; Next; TopElem = Tmp -&gt; Data; free(Tmp); &#125;return TopElem;&#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}